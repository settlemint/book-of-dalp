---
title: "Issuance Flow"
description: "How ATK moves a regulated asset from blueprint to secondary-ready state without scripting the fundamentals from scratch."
---

## What the lifecycle engine automates

The Asset Tokenization Kit (ATK) ships the full issuance stack instead of leaving teams to stitch contracts, identity, and UI together. The `ATKSystemFactory` contract creates a governed system instance in a single transaction, wiring identity, compliance, registry, and access-control modules before any asset work begins. Once bootstrapped, the Token Factory Registry exposes dedicated factories for bond, equity, fund, stablecoin, and deposit instruments, each composed from SMART extensions (`SMARTUpgradeable`, `SMARTYieldUpgradeable`, `SMARTTokenAccessManagedUpgradeable`, and more) so supply limits, redemption mechanics, and lifecycle hooks are first-class capabilities rather than one-off scripts.

On the front end, the kit’s TanStack-powered Asset Designer (`kit/dapp/src/components/asset-designer`) gives business users a feature-complete configuration surface. Every field—denomination asset, dividend yield model, coupon cadence, country restrictions—maps directly to contract parameters, eliminating the translation errors that slow legal reviews. The designer calls typed ORPC procedures, which in turn orchestrate contract factories, the identity registry, and compliance module registry.

<Mermaid
  chart={`
flowchart LR
  designer["Asset Designer"] -->|ORPC createAsset| orpc["Typed ORPC server"]
  orpc -->|Deploy via| factory["ATK token factory"]
  factory --> identity["Identity factory" ]
  identity --> registry["Identity registry"]
  factory --> compliance["Compliance contract"]
  compliance --> modules["Compliance module registry"]
  factory --> indexers["Subgraph indexers"]
  indexers --> captable["Cap table + analytics"]
`}
/>

## Lifecycle coverage end to end

1. **System bring-up:** `createSystem()` deploys the centralized Access Manager, registers identity verification as a default compliance module, and logs the system for discovery. Admins receive bootstrap roles (`DEFAULT_ADMIN_ROLE`, `SYSTEM_MANAGER_ROLE`) automatically, so they can proceed directly to factory registration.
2. **Template selection:** Token factories encode asset-specific guardrails. For example, the bond implementation enforces maturity, denomination, redemption accounting, and cap logic, while the fund implementation focuses on share classes, NAV interactions, and custodian flows.
3. **Compliance scoping:** Global compliance modules—blacklist/whitelist, jurisdiction gates, investor concentration checks—can be set once on the system and apply to every token. Token-specific rules can be layered from the dApp without contract redeployments.
4. **Identity binding:** Every asset gets an OnchainID contract identity via the identity factory; trusted issuers are registered so they can append legal attestations automatically. Because the Portal API already understands the claim topics defined in `ATKTopics.sol`, onboarding and accreditation surfaces stay synchronized with asset policy.
5. **Event capture:** Subgraph mappings in `kit/subgraph/src/token` and `.../stats` project creation, allocation, transfer, and redemption events into a real-time cap table. The dApp and Portal read from the same index, so finance, compliance, and ops teams work from a single source of truth.

<Mermaid
  chart={`
sequenceDiagram
  participant Admin
  participant FactoryRegistry
  participant TokenFactory
  participant IdentityFactory
  participant Compliance
  participant Subgraph
  Admin->>FactoryRegistry: registerFactory(assetType)
  Admin->>TokenFactory: createToken(params)
  TokenFactory->>IdentityFactory: createContractIdentity()
  IdentityFactory-->>TokenFactory: contractIdentityAddress
  TokenFactory->>Compliance: configureModules(token)
  TokenFactory->>Subgraph: emit Deployment, ModuleConfigured
  Subgraph-->>Admin: indexed token + compliance metadata
`}
/>

## Tooling for human and automated teams

- **Self-service and API parity:** The Asset Manager UI and ORPC routes expose identical coverage—mint, burn, lock, whitelist, distribute, and corporate action initiation—so human operators and automated desks can share workflows.
- **Genesis and artifact automation:** `bun run artifacts` regenerates the genesis file, Hasura migrations, Portal ABI bundle, and subgraph deployment artifacts whenever a factory or module changes, making it safe to iterate on templates without drifting downstream services.
- **Testing baked in:** Foundry scenarios (`kit/contracts/test`) and Playwright integration tests (`kit/e2e/ui-tests`) already exercise issuance, investor onboarding, and lifecycle operations. Developers validate changes locally before touching production-like environments.

## What changes for programme leads

Issuers stop translating policy into ad-hoc scripts; the lifecycle path is compiled from libraries that already embed compliance expectations, role separation, and audit hooks. Product teams iterate on new asset classes simply by registering a factory and, if needed, shipping an addon. Compliance officers review enforceable parameters rather than prose. Engineering focuses on differentiation—distribution mechanics, data products, partner APIs—because the foundations are ready on day one.

The net result: moving from term sheet to compliant, indexable, and serviced assets becomes a predictable playbook instead of an integration project.
