---
title: "Deployment & White-Label"
description: "ATK ships Helm charts, Compose blueprints, and managed Console automation so institutions own runtime, branding, and evidence from day one."
---

import { Tab, Tabs } from "@/components/tabs";

## Deployment choices that pass review

ATK supports three delivery patterns that run the same code and APIs:

<Tabs items={["Self-hosted Kubernetes", "Local & dev automation", "Managed Console"]}>
  <Tab>
    <p>
      Deploy <code>kit/charts/atk</code> into your cluster to run the dApp, REST API backend, Besu network, Blockscout, Hasura, MinIO, and observability stack. Environment-specific values, disruption budgets, and network policies come baked in so you retain full operational control.
    </p>
  </Tab>
  <Tab>
    <p>
      Use <code>docker-compose.yml</code> with <code>bun run dev:up</code> to reproduce the full platform for developers and QA. The Compose stack pulls the exact artifacts Helm deploys, keeping dev, staging, and production honest.
    </p>
  </Tab>
  <Tab>
    <p>
      Let SettleMint operate the stack via Console while you still access tenant automation, exports, and Helm assets. Institutions can prove tenancy boundaries today and transition to self-hosting whenever procurement requires it.
    </p>
  </Tab>
</Tabs>

Procurement sees real controls instead of promises: you can point to the charts, the pipelines, and the evidence before diligence even starts.

## Branding without rewrites

- The Next.js app (`kit/dapp`) ships theming, tokens, and brand packs so tenants can match their visual identity without forking screens.
- Helm ingress values let you attach custom domains, certificates, and CDN strategies to each surface while keeping TLS under your policy.
- Portal APIs and webhooks stay consistent, letting partners embed flows or build new UIs while regulated functions remain in your environment.

## Infrastructure building blocks

- Hyperledger Besu, Blockscout, and supporting services swap through values overrides; images, storage classes, or cloud primitives change without touching templates.
- Tooling such as `kit/charts/tools/aws-marketplace-automation.ts` and the environment hierarchy document promotion paths from local to staging to production, including feature-branch environments.
- Observability is bundled: Prometheus, Grafana, Loki, and alert routing stream metrics and logs into your SIEM from day one.

## Security, identity, audit

- Secrets land in Kubernetes or external stores, and charts expose OIDC hooks for services like MinIO while network policies enforce least privilege between pods.
- The dApp and REST API backend (documented via OpenAPI and implemented in the `orpc` module) already model OAuth flows, MFA checks, and granular role validation, so existing identity providers plug straight in.
- Every component emits structured logs and metrics; forwarding them to your observability stack gives compliance the audit trails it expects without extra engineering.

## Operational readiness

- `bun run ci` packages formatting, contract compilation, code generation, linting, and testing; the same workflow underpins Console deployments and self-managed pipelines.
- Deployment docs cover backups, disaster recovery, and capacity planning, cutting the time needed to answer RTO/RPO questions.
- Moving between models is configuration work: Compose for development, Helm for self-managed clusters, and Console for managed service all share contracts, schema, and the same OpenAPI-driven REST endpoints.

**Bottom line:** ATK is deployable market infrastructure. Own the runtime, match your brand, and let every other chapter build on a stack you already control.
