---
title: "SMART Protocol"
description: "A continuous narrative covering the SMART Protocol and the full Asset Tokenization Kit (ATK) contract stack for the paperback edition."
---

import { TypeTable } from "@/components/type-table";
import { Steps, Step } from "@/components/steps";

SettleMint keeps the SMART Protocol separate from the Asset Tokenization Kit (ATK) so each stream can move at its own pace while staying in sync. SMART stays a standards friendly specification built on ERC-20 and ERC-3643 with modular compliance, OnChainID hooks, upgrade ready variants, and trusted forwarder support for gasless calls. ATK carries the production kit: central registries, typed proxies, deterministic factories, role segmentation, and operator tooling. This chapter tracks both layers so the paperback reader still gets the full story.

<Callout type="info" title="Snapshot before you start">
  SMART defines the rules and interfaces. ATK keeps those rules live with registries, factories, and tooling. Pair them to ship compliant assets without freezing your change window.
</Callout>

### SMART spec essentials

- Tokens stay ERC-20 and ERC-3643 in standard and upgradeable variants, so wallets and DeFi tools keep working.
- Compliance modules take per-token parameters and support AND, OR, and NOT logic instead of brittle conditionals.
- Identity checks reuse shared registries and trusted issuer registries that monitor claim topics.
- Trusted forwarders cover gasless submissions, while ERC-165 broadcasts supported interfaces to tooling.
- Recovery stays two-step: one action updates identity, a separate action lets holders reclaim balances.

### ATK stack essentials

- Deterministic factories spin up system, registry, and token contracts with predictable addresses.
- Typed proxies preserve storage layouts so teams can swap implementations after full testing.
- Segmented roles cover governance, sale management, fund withdrawals, and monitoring without overlap.
- Operational addons handle airdrops, vaults, settlement helpers, yield schedules, and sale flows.
- Central registries record identities, compliance modules, and addon entries for quick discovery.

### Quick reference points

- **Identity first.** OnChainID registries keep issuer, investor, and custodian personas consistent across instruments, and a single attestation can feed many tokens.
- **Compliance on rails.** Modules share one orchestrator and accept per-token parameters, so teams mix allow lists, block lists, investor counts, and time locks without forking code.
- **Operations ready.** Factories, role templates, and monitoring hooks sit alongside the contracts, making upgrades, vesting schedules, and event tracking routine.

### How the layers click

SMART maps the token behaviours while ATK coordinates the environment. The diagram keeps the story compact.

<Mermaid
  chart={`
  graph LR
    Core[SMART Core Token]
    Core --> Upgradeable[Upgradeable • Fixed]
    Core --> ComplianceHooks[Compliance Hooks]
    Core --> IdentityHooks[Identity Hooks]
    Core --> Extensions[Extension Library]
    Core --> MetaTx[ERC-2771 Forwarders]
    Core --> Interfaces[ERC-165 Introspection]
    Extensions --> Burnable[Burnable / Redeemable]
    Extensions --> Custodian[Custodian Controls]
    Extensions --> Yield[Yield Schedules]
    Extensions --> Voting[Voting Rights]
    Extensions --> Historical[Historical Balances]
    Extensions --> Collateral[Collateral Guards]
    ComplianceHooks --> Modules[Reusable Modules]
    IdentityHooks --> Registry[Identity Registry]
    IdentityHooks --> TrustedIssuers[Trusted Issuers]
    style Core fill:#fce4ec,stroke:#ad1457,stroke-width:2px
    style Extensions fill:#fff8e1,stroke:#f57f17,stroke-width:1.5px
    style ComplianceHooks fill:#e3f2fd,stroke:#1565c0,stroke-width:1.5px
    style IdentityHooks fill:#ede7f6,stroke:#4527a0,stroke-width:1.5px
  `}
/>

Extensions stay modular, yet each shares the same core token so you can mix burning, custodian controls, yield schedules, voting rights, historical balances, or collateral guards as business needs shift. Meta transaction support and ERC-165 detection survive whichever blend you choose. Identity registries stay token agnostic, and each token pushes its own expressions into the verifier.

### Extension library cheat sheet

#### Token behaviour extensions

- <code>SMARTBurnable</code> and <code>SMARTRedeemable</code> cover administrative burns and holder-led redemptions.
- <code>SMARTCollateral</code> and <code>SMARTCustodian</code> enforce asset backing and custodian checkpoints.
- <code>SMARTYield</code> schedules coupon or distribution logic, while <code>SMARTVoting</code> keeps proposal tracking embedded.
- <code>SMARTHistoricalBalances</code> retains snapshots for audits, treasury reporting, and voting tallies.

#### Identity and registry modules

- Allow list and block list modules toggle wallets or identities without redeploying token logic.
- Identity verification modules express “contract identity OR (KYC AND AML)” type logic to match jurisdictional policy.
- Shared identity and trusted issuer registries keep claim validation centralised and reusable.
- Claim authorisation flows let trusted parties add or revoke claims under auditable rules.

#### Transfer and supply controls

- Investor count modules enforce hard caps by country or globally, with filters for specific claims.
- Supply limit modules cap aggregate supply while respecting compliance hooks.
- Transfer approval modules require administrators to sign off on movements when manual oversight is needed.
- Time lock modules enforce holding periods yet honour exemption expressions for accredited holders.

#### Operational addons

- Sale engines manage payment tokens, pricing, vesting, and limits inside a single factory pattern.
- Airdrop tools, vault integrations, and settlement helpers plug into the addon registry for quick discovery.
- Yield schedulers automate interest events while logging snapshots for regulators.
- Monitoring feeds surface events so operators can react before compliance breaks.

### Compliance flow

You know what? The compliance path is easier to reason about once you see the flow below.

<Mermaid
  chart={`
  graph TB
      Token[SMART Token] --> CC[Compliance Contract]
      CC --> ModuleA[Compliance Module]
      CC --> ModuleB[Compliance Module]
      CC --> ModuleN[Compliance Module]
      ModuleA --> IR[Identity Registry]
      ModuleB --> IR
      ModuleN --> IR
      IR --> TIR[Trusted Issuers Registry]
      IR --> TSR[Topic Scheme Registry]
      IR --> Identities[(Identity Contracts)]
  `}
/>

Tokens hand transfers to a compliance orchestrator, that orchestrator calls configured modules, and each module interrogates shared identity registries, trusted issuer registries, and topic scheme registries before allowing the move. Modules accept encoded parameters so a single deployment can serve multiple tokens. Logical expressions use AND, OR, and NOT operators, letting teams combine jurisdictional clauses without duplicating code. Because the registries are reusable, one set of issuers can satisfy many instruments. No other public suite covers this mix today, so SMART remains the open avenue for regulated token projects.

Identity modules plug in directly to OnChainID. Allow list modules confirm that a wallet is approved and can request proof of identity ownership. Block list modules quarantine flagged wallets without touching identity level rules. Address block list modules target individual addresses for quick action. Every module ships configuration structs that spell out the required expressions, exemptions, or claim topics so operations stay explicit.

### Sale configuration cheat sheet

<TypeTable
  type={{
    startTime: {
      description: <>First block timestamp that allows purchases. Used during setup to gate go-live.</>,
      type: <code>uint64</code>,
      default: <code>0</code>,
      required: true,
    },
    endTime: {
      description: <>Final timestamp after which purchases halt. Paired with pause controls for manual stops.</>,
      type: <code>uint64</code>,
      default: <code>0</code>,
      required: true,
    },
    acceptedCurrencies: {
      description: <>List of ERC-20 addresses plus the zero address marker for native currency payments.</>,
      type: <code>address[]</code>,
      required: true,
    },
    pricePerCurrency: {
      description: <>Per currency pricing so native and token based buyers pay the right amount.</>,
      type: <code>mapping(address =&gt; uint256)</code>,
      required: true,
    },
    purchaseLimit: {
      description: <>Limit struct that guards per buyer caps and global hard caps.</>,
      type: <code>struct Limits</code>,
      required: false,
    },
    vesting: {
      description: <>Linear vesting fields with cliffs and release schedules for delayed delivery.</>,
      type: <code>struct Vesting</code>,
      required: false,
    },
    identityExpression: {
      description: <>Encoded compliance expression that every buyer must satisfy at purchase time.</>,
      type: <code>bytes</code>,
      required: true,
    },
    trustedForwarder: {
      description: <>Forwarder address that enables ERC-2771 meta transactions for buyers who need gas support.</>,
      type: <code>address</code>,
      required: false,
    },
  }}
/>

The sale contract validates timestamps, payment amounts, and addresses before accepting funds. It supports both immediate delivery and vested delivery while logging events for purchases, withdrawals, state changes, currency updates, and administrative actions. Custom errors flag timing violations, purchase limit breaches, unauthorized attempts, and invalid parameters.

<Steps>
  <Step>
    <strong>Setup.</strong> Administrators configure timing, currencies, pricing, vesting, and compliance expressions, then preview deterministic addresses.
  </Step>
  <Step>
    <strong>Active.</strong> Purchases flow through, limits stay enforced, and payments settle in native or ERC-20 tokens.
  </Step>
  <Step>
    <strong>Paused.</strong> Operators pause activity without losing configuration so investigations or audits can finish safely.
  </Step>
  <Step>
    <strong>Ended.</strong> Administrators close the sale, withdraw remaining tokens, and release funds while final reports generate.
  </Step>
</Steps>

<Mermaid
  chart={`
  stateDiagram-v2
      [*] --> Setup
      Setup --> Active: start time reached
      Active --> Paused: pause()
      Paused --> Active: resume()
      Active --> Ended: endSale()
      Paused --> Ended: endSale()
      Ended --> [*]
  `}
/>

Security guidance leans on clear role separation: <code>DEFAULT_ADMIN_ROLE</code> handles assignments, <code>SALE_ADMIN_ROLE</code> governs configuration, and <code>FUNDS_MANAGER_ROLE</code> controls withdrawals. ReentrancyGuard protects state, and testing should cover purchase permutations, vesting releases, access control, and compliance integration. Deployment checklists still matter: deploy implementations, configure factories, assign roles, point trusted forwarders, verify contracts, and run dry rehearsals before launch.

### Upgrade strategy

SMART ships both standard and UUPS ready upgradeable contracts. Teams choose immutability or proxy based upgrades per instrument while sharing security reviewed storage layouts. ATK runs upgrades through <code>ATKSystem</code>, keeping every change auditable and letting administrators roll back by pointing proxies to previous implementations when incidents arise.

### OnChainID extensions

Composition over inheritance stays the guiding principle. Developers combine <code>OnChainIdentity</code>, <code>OnChainContractIdentity</code>, <code>OnChainIdentityWithRevocation</code>, <code>ERC734</code>, <code>ERC735</code>, <code>ClaimAuthorizationExtension</code>, and <code>IClaimAuthorizer</code> to build the identity contract they need. Contract identities may issue claims directly through <code>issueClaimTo</code>, while trusted issuers rely on the claim authorisation system that stores who may add or remove claims for each topic. Authorisation can be topic specific and revocable, and the system exposes functions to grant and revoke rights programmatically. <code>OnChainIdentityWithRevocation</code> extends the base identity with revocation support without forcing state migrations, keeping identities adaptable as regulations change.

### Bringing it all together

Standing up a fresh ATK deployment means creating or reusing a system instance, instantiating the central access manager, and bootstrapping identity, compliance, issuer, and topic infrastructures. Identity factory contracts mint OnChainID identities for investors, issuers, custodians, or downstream applications. Compliance modules register through the module registry with encoded expressions and thresholds that mirror legal requirements. Asset factories deploy proxies for the chosen instrument and register them so downstream systems resolve every address from a single hub. Operational addons—airdrop engines, vaults, XvP settlements, yield schedulers, token sale contracts—register with the addon registry for quick discovery. Role assignments enforce operational discipline while monitoring captures every critical event. Upgrade plans flow through <code>ATKSystem</code>, keeping governance central and auditable. With SMART providing an extensible, standards friendly token core and ATK layering system infrastructure, asset tooling, sale orchestration, and identity extensions, institutions gain a cohesive tokenization platform that reads well in print and holds up in production.
